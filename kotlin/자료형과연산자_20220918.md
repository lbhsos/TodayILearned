# 변수와 자료형, 연산자
## 정수 자료형
- 정수 자료형은 양수, 음수, 0을 나타낸다. 
- 코틀린의 정수 자료형은 부호가 있는 것과 부호가 없는 것으로 나눌 수 있다. 
- 숫자크기에 상관없이 기본은 모두 Int형으로 추론됩니다.

## 논리 자료형
- 참, 거짓을 표현하는 논리 자료형으로 true, false가 있다.

## 실수 자료형
- 실수 자료형은 실수를 저장하기 위해 사용한다.
- 정수와 마찬가지로 자료형을 명시하지 않으면 **Double**형으로 추론된다.
- 만약 Float형으로 지정하고 싶으면 간략하게 식별자 F를 실수 옆에 붙이는 방법을 사용하면 된다.
- 부동 소수점 방식은 실수를 가수, 지수로 나누어 표현하는 방법이다.

```kotlin
val exp03 = 3.14E-2 // 왼쪽으로 소수점 2칸 이동, 0.0314
val exp04 = 3.14e2 // 오른쪽으로 소수점 2칸 이동, 314
```

## 엘비스 연산자(?:)
변수가 null인지 아닌지 검사하여 null이 아니라면 왼쪽의 식을 실행하고 null이 아니라면 오른쪽의 식을 실행한다.

## 자료형 변환이 필요한 이유
코틀린 자료형은 모두 참조형으로 선언한다. 그러나 컴파일을 거쳐 최적화 될 때는 Int, Long, Short와 같은 참조형 자료형은 기본형 자료형으로 변환된다. 
코틀린에서는 자료형이 다른 변수에 재할당하면 자동 형 변환외 되지 않고 자료형 불일치 오류(type mismatch)가 발생한다.

```kotlin
val a: Int = 1 // 정수형 변수 a 선언, 1 할당
val b: Double = a // 자료형 불일치 오류 발생
val c: Int = 1.1 // 자료형 불일치 오류 발생
```
- 변수 a는 정수형으로 실수형 변수 b에 다시 할당할 수 없다.
- 정수형 자료형인 c에 1.1을 대입하는 것도 안된다.
- 만일 자료형을 변환해 할당하고 싶다면 자료형 변환 메서드를 이용해야한다.
    - toByte: Byte
    - toLong: Long
    - toShort: Short
    - toFloat: Float
    - toInt: Int
    - toDouble: Double
    - toChar: Char

## 기본형과 참조형 자료형의 비교
자료형을 비교할 때는 단순히 값만 비교하는 방법과 참조 주소까지 비교하는 방법이 있다. 단순히 값만 비교할 때는 이중등호(==)를 사용하고, 참조 주소를 비교하려면 삼중 등호(===)를 사용한다.

## 스마트 캐스트
만약 어떤 값이 정수, 실수가 모두 가능하다면 그 때 마다 자료형을 변환할 수도 있지만 **Number**형을 사용하면 숫자를 저장하기 위한 특수한 자료형 객체를 만들 수 있다.
- Number 형으로 정의된 변수에는 저장되는 값에 따라 실수, 정수로 자료형이 변환된다. 
- 단, String은 Number 하위에 속한 객체가 아니므로 변환할 수 없다.

## 묵시적 변환
- Any 형은 자료형이 특별히 정해지지 않은 경우 사용한다.
- 코틀린의 Any형은 모든 클래스의 뿌리이다. 
- Int나 String, 사용자가 직접 만든 클래스까지 모두 Any 형의 자식 클래스이다. 
- 코틀린의 모든 클래스는 Any 형이라는 슈퍼 클래스(Superclass)를 가진다.
## 비트 연산자
|표현식|설명|
|--|--|
|4.shl(bits)|4를 표현하는 비트를 bits만큼 왼쪽으로 이동, 부호 있음    (ex. 4.shl(3) 은 다음과 같이 표현된다. 100 -> 100000)|
|4.shr(bits)|4를 표현하는 비트를 bits만큼 오른쪽으로 이동, 부호 있음|
|4.ushr(bits)|4를 표현하는 비트를 bits만큼 오른쪽으로 이동, 부호 없음|
|4.and(bits)|4를 표현하는 비트와 bits를 표현하는 비트로 논리곱 연산|
|4.or(bits)|4를 표현하는 비트와 bits를 표현하는 비트로 논리합 연산|
|4.xor(bits)|4를 표현하는 비트와 bits를 표현하는 비트로 배타적 연산|
|4.inv()|4를 표현하는 비트 모두 뒤집음|
